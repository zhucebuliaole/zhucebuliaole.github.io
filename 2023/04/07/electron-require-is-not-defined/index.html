<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>electron require is not defined</title><meta name="description" content="🎇Happy Chinese New Year 🐇！"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-66E4L626Z5', 'lele233.tech');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/icon.svg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="本篇文章是用于解决最新版本electron在浏览器侧文件如何引入nodejs下的包的问题。主要基于The ultimate Electron guide
编写。
Chromium 和 Node 如何交互？Electron 应用程序是一个npm项目，它包含electron框架作为依赖项。npm 项目的主要入口点是 Electron 应用程序的入口点，我们可以在其中选择性地包含我们想要的任何 Node API，以及创建并呈现UI的前端浏览器。  
Chromium and ElectronChromium 从它的主进程开始。从主进程中，可以生成**渲染器进程(renderer)**。渲染器进程与[browser]窗口同义。主进程持有对渲染器进程的引用，并可以根据需要创建/删除渲染器进程。在大多数 Electro.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="le的博客" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Qile Liang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">electron require is not defined</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chromium-%E5%92%8C-Node-%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-text">Chromium 和 Node 如何交互？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chromium-and-Electron"><span class="toc-text">Chromium and Electron</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-API-in-Electron"><span class="toc-text">Node API in Electron</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%89%88electron%E4%B9%8B%E5%89%8D"><span class="toc-text">第五版electron之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Electron-5-and-IPC"><span class="toc-text">Electron 5+ and IPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preload-and-security"><span class="toc-text">Preload and security</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preload-with-context-isolation"><span class="toc-text">Preload with context isolation</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">electron require is not defined</h1><time class="has-text-grey" datetime="2023-04-07T03:50:43.000Z">2023-04-07</time><article class="mt-2 post-content"><p>本篇文章是用于解决最新版本electron在浏览器侧文件如何引入nodejs下的包的问题。主要基于<a target="_blank" rel="noopener" href="https://www.debugandrelease.com/the-ultimate-electron-guide/">The ultimate Electron guide
</a>编写。</p>
<h1 id="Chromium-和-Node-如何交互？"><a href="#Chromium-和-Node-如何交互？" class="headerlink" title="Chromium 和 Node 如何交互？"></a>Chromium 和 Node 如何交互？</h1><p><strong>Electron</strong> 应用程序是一个<strong>npm项目</strong>，它包含electron框架作为依赖项。npm 项目的主要入口点是 Electron 应用程序的入口点，我们可以在其中选择性地包含我们想要的任何 <strong>Node API</strong>，以及创建并呈现UI的前端浏览器。<br><img src="https://s2.loli.net/2023/04/07/2lC5EGMu6znIA1V.png" alt="actual-arch-v2.png">  </p>
<h1 id="Chromium-and-Electron"><a href="#Chromium-and-Electron" class="headerlink" title="Chromium and Electron"></a>Chromium and Electron</h1><p>Chromium 从它的主进程开始。从主进程中，可以生成**渲染器进程(renderer)**。渲染器进程与[browser]窗口同义。主进程持有对渲染器进程的引用，并可以根据需要创建/删除渲染器进程。在大多数 Electron 应用程序中，只会创建一个渲染器进程，但如果需要更多渲染器进程，则没有硬性限制。<br>渲染进程与主进程的关系如图。<br><img src="https://s2.loli.net/2023/04/07/2QjwulY35UpT1Ve.png" alt="chromium-and-renderer-1-.png"><br>如若我们把渲染进程加入到之前的示意图中我们可以得到：<br><img src="https://s2.loli.net/2023/04/07/BitAfExRaeUZCbH.png" alt="chromium-in-npm-project.png"><br>我们可以通过创建一个window并使用loadurl等方法创建一个render进程。</p>
<h1 id="Node-API-in-Electron"><a href="#Node-API-in-Electron" class="headerlink" title="Node API in Electron"></a>Node API in Electron</h1><h2 id="第五版electron之前"><a href="#第五版electron之前" class="headerlink" title="第五版electron之前"></a>第五版electron之前</h2><p>在老版本的Electron中，我们可以直接倒入Node。只要我们创建window的时候启用<strong>nodeIntegrarion=true</strong>。</p>
<pre><code class="javascript">// in main.js
function createWindow () {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration:true //here
    }
</code></pre>
<p>此时我们的程序是可以随意require，访问node的。但是随之而来的就是很大的安全问题，如没有隔离等。<br><img src="https://s2.loli.net/2023/04/07/wRMW4hlptcVboXT.png" alt="node-in-renderer-process.png"></p>
<h2 id="Electron-5-and-IPC"><a href="#Electron-5-and-IPC" class="headerlink" title="Electron 5+ and IPC"></a>Electron 5+ and IPC</h2><p>如果我们无法在渲染器中引入node API 那我们该怎么办呢？ **IPC (inter-process communication)**is all you need! 事实上我们的主进程仅仅拥有renderer的引用，因此我们必须通过IPC进行通信。<br>IPC是基于事件进行通信的，实施IPC时，所有进程会监听事件，事件发生时则会进行执行。<br><img src="https://s2.loli.net/2023/04/07/uBwXtxWRGUZI89e.png" alt="chromium-ipc-listeners-1-.png">  </p>
<pre><code class="javascript">// code in main
const {
  app,
  BrowserWindow,
  ipcMain
} = require("electron");
const path = require("path");

// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
let win;

async function createWindow() {

  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600
  });

  // Load app
  win.loadFile(path.join(__dirname, "dist/index.html"));

  // rest of code..
}

app.on("ready", createWindow);

// Create an listener for the event "A"
ipcMain.on("A", (event, args) =&gt; {
    
  // Send result back to renderer process
  win.webContents.send("D", {success: true});
});
</code></pre>
<pre><code class="javascript">// code in renderer
const {
    ipcRenderer
} = require("electron");

window.sendToA = function(){
    ipcRenderer.send("A");
};

window.receiveFromD = function(func){
    ipcRenderer.on("D", (event, ...args) =&gt; func(event, ...args));
};
</code></pre>
<p>然而这只是示例，我们并不能在renderer.js 中直接<code>require("electron")</code> </p>
<h2 id="Preload-and-security"><a href="#Preload-and-security" class="headerlink" title="Preload and security"></a>Preload and security</h2><p>我特意忽略了在主进程和渲染进程之间通过 IPC 进行通信时所需的重要细节，这就是 Electron 团队定义为预加载脚本的内容。</p>
<p>由于我们的渲染器进程无法访问 Node，因此它们自己无法创建所需的 IPC 绑定！这个问题的答案是通过预加载脚本(<strong>preload.js</strong>)，它可以访问 Node API。我们在预加载脚本中创建渲染器 IPC 绑定；预加载脚本的内容被注入到我们的渲染器进程中.<br>我们可以在创建window的时候导入preload。</p>
<pre><code class="javascript">// Create the browser window.
win = new BrowserWindow({
  width: 800,
  height: 600,
  webPreferences: {
    preload: path.join(__dirname, "preload.js")    
  }
});
</code></pre>
<p>但是事实上直接使用preload意味着我们全权信任渲染端，也就是服务器端，这很容易造成安全问题。<br>后面的一段代码将提供一个示例，说明这样使用preload有怎么样的问题。  </p>
<pre><code class="javascript">// preload.js
const {
    ipcRenderer
} = require("electron");

window.send = function(){
    return ipcRenderer.send;
};

window.receive = function(){
    return ipcRenderer.on;
};
</code></pre>
<pre><code class="html">&lt;!-- code in index.html --&gt;
&lt;!doctype html&gt;
&lt;html lang="en-US"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"/&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;
        // Called when message received from main process
        window.receive()("fromMain", (data) =&gt; {
            console.log(`Received ${data} from main process`);
        });

        // Send a message to the main process
        window.send()("toMain", "some data");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">// code in main.js
const {
  app,
  BrowserWindow,
  ipcMain
} = require("electron");
const path = require("path");
const fs = require("fs");

// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
let win;

async function createWindow() {

  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, "preload.js") // use a preload script
    }
  });

  // Load app
  win.loadFile(path.join(__dirname, "dist/index.html"));

  // rest of code..
}

app.on("ready", createWindow);

// Create a listener for deleting files
ipcMain.on("deleteFile", (event, args) =&gt; {
  fs.unlinkSync(args.filePath);
    
  // Send the result back to the renderer process
  win.webContents.send("deleteFileResponse", true);
});
</code></pre>
<p>如果我们错误地信任我们的渲染器进程，并且我们的代码前端被黑客攻击以将文件路径列表发送到“deleteFile”通道，我们可能会丢失计算机上的重要文件。这可能是一个人为的例子，但它表明如果我们不小心，有人可能会利用我们的代码来执行我们不希望的操作。<br>为了使用 IPC而不会受到函数覆盖的影响，我们需要使用上下文隔离(<strong>context isolation</strong>)。简而言之，上下文隔离创建了一个您在预加载中定义的不可变对象。渲染器进程无法更改任何具有上下文隔离的内容。幸运的是，设置上下文隔离非常容易。</p>
<h2 id="Preload-with-context-isolation"><a href="#Preload-with-context-isolation" class="headerlink" title="Preload with context isolation"></a>Preload with context isolation</h2><p>btw,从Electron版本 12开始，<strong>值contextIsolation默认为 true。</strong><br>我们在引入windows时使用的代码应该设置contextisolation值.</p>
<pre><code class="javascript">// Create the browser window.
// code in main.js
win = new BrowserWindow({
  width: 800,
  height: 600,
  webPreferences: {
    contextIsolation: true,
    preload: path.join(__dirname, "preload.js")    
  }
});
</code></pre>
<p>我们的预加载需要稍微改变以支持上下文隔离；我们需要使用electron中的<code>contextBridge</code>.</p>
<pre><code class="javascript">// code in preload.js
const {
    ipcRenderer,
    contextBridge
} = require("electron");

// Expose protected methods off of window (ie.
// window.api.sendToA) in order to use ipcRenderer
// without exposing the entire object
contextBridge.exposeInMainWorld("api", {
    sendToA: function(){
        ipcRenderer.send("A");
    },
    receiveFromD: function(func)
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/03/06/coredns%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E4%B8%8Ecorefile%E5%8E%9F%E7%90%86/" title="coredns插件原理与corefile原理"><span class="has-text-weight-semibold">下一页: coredns插件原理与corefile原理</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="zhucebuliaole/zhucebuliaole.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhucebuliaole"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/liang-qi-le"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/qile-liang-89b178194/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--></section><p><span>Copyright ©</span><span> Qile Liang 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>