<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>le的博客</title>
  
  <subtitle>LE&#39;S BLOG </subtitle>
  <link href="https://lele233.tech/atom.xml" rel="self"/>
  
  <link href="https://lele233.tech/"/>
  <updated>2023-09-19T14:33:34.829Z</updated>
  <id>https://lele233.tech/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Can I call class variables without cls?</title>
    <link href="https://lele233.tech/2023/09/19/Can-I-call-class-variables-without-cls/"/>
    <id>https://lele233.tech/2023/09/19/Can-I-call-class-variables-without-cls/</id>
    <published>2023-09-19T13:48:44.000Z</published>
    <updated>2023-09-19T14:33:34.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Can-I-call-class-attributes-without-cls-in-Python"><a href="#Can-I-call-class-attributes-without-cls-in-Python" class="headerlink" title="Can I call class attributes without cls in Python ?"></a>Can I call class attributes without cls in Python ?</h1><p>When we have a class variable but we find that we need call it in a non-class-method. Can we do operation like that? The answer is : <strong>Yes</strong> and <strong>no</strong>.</p><h2 id="Why-the-answer-is-yes"><a href="#Why-the-answer-is-yes" class="headerlink" title="Why the answer is yes?"></a>Why the answer is yes?</h2><p>For any class attributes , we can use <strong>“self”</strong> to call them. After the first time we to do so, we will create an instance attributes implicitly ( at the most of time). Let me start with an example. </p><pre><code class="python">class MyClass:    class_var = 1    def __init__(self, name):        self.name = name    # a method to call class variable    def noclass_method(self):        self.class_var += 1        print(self.class_var)        print(id(self.class_var))        return    # a method to show class variable    @classmethod    def show_class_var(cls):        print(cls.class_var)        print(id(cls.class_var))if __name__ == '__main__':    a = MyClass('a')    a.noclass_method()    print("-------no class method-------")    MyClass.show_class_var()    print("-------class variable-------")    print(a.class_var)    print("--------------")    b = MyClass('b')    b.noclass_method()    print("-------no class method-------")    MyClass.show_class_var()    print("-------class variable-------")# result :# 2# 4372670800# -------no class method-------# 1# 4372670768# -------class variable-------# 2# --------------# 2# 4372670800# 3# 4382206320# -------no class method-------# 1 # 4372670768# -------class variable-------</code></pre><p>For the first instance “a” we can find that <code>self.class_var</code> has a different address with class variable and its value change to “2” ( 1+1 ).  When calling classmethod <code>show_class_var()</code> ,  result shows that we dont change class attribute which initialize as “1”. And then , for instance “b” we call <code>noclass_method()</code>   twice and the <code>self.class_var</code>  equals to 3 (1+1+1) which means the two <code>slef.class_var</code> is instance variables actually. So for the first time an instance call it using key word <strong>“self”</strong> a instance variable will be created. And after that when we call a.class_var we will get instance variable. <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces:~:text=If%20the%20same%20attribute%20name%20occurs%20in%20both%20an%20instance%20and%20in%20a%20class%2C%20then%20attribute%20lookup%20prioritizes%20the%20instance%3A">The official document's example shows what will happend if class method and instance method has same name</a>. </p><h2 id="Why-the-answer-is-no"><a href="#Why-the-answer-is-no" class="headerlink" title="Why the answer is no."></a>Why the answer is no.</h2><p>If the class attribute is a mutable data type, call it by key word “self” will not create a new instance attribute. In other words, your method will change the shared class attribute. <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces:~:text=For%20example%2C%20the%20tricks%20list%20in%20the%20following%20code%20should%20not%20be%20used%20as%20a%20class%20variable%20because%20just%20a%20single%20list%20would%20be%20shared%20by%20all%20Dog%20instances%3A">Here is an example from official document.</a></p><pre><code class="python">class Dog:    tricks = []             # mistaken use of a class variable    def __init__(self, name):        self.name = name    def add_trick(self, trick):        self.tricks.append(trick)&gt;&gt;&gt; d = Dog('Fido')&gt;&gt;&gt; e = Dog('Buddy')&gt;&gt;&gt; d.add_trick('roll over')&gt;&gt;&gt; e.add_trick('play dead')&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs['roll over', 'play dead']</code></pre><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We can call class attributes by using <strong>“self”</strong> . If the attribute is a immutable data type, it will create an instance attribute implicitly. But if the attribute is a mutable data type, we can still call it but will modify the shared class attribute.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Can-I-call-class-attributes-without-cls-in-Python&quot;&gt;&lt;a href=&quot;#Can-I-call-class-attributes-without-cls-in-Python&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>golang  xxx is relative, but relative import paths are not supported in module mode</title>
    <link href="https://lele233.tech/2023/06/19/golang-xxx-is-relative-but-relative-import-paths-are-not-supported-in-module-mode/"/>
    <id>https://lele233.tech/2023/06/19/golang-xxx-is-relative-but-relative-import-paths-are-not-supported-in-module-mode/</id>
    <published>2023-06-19T12:26:18.000Z</published>
    <updated>2023-06-19T12:55:53.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-package-management"><a href="#Golang-package-management" class="headerlink" title="Golang package management"></a>Golang package management</h1><p>Go has its own package management system named “go modules”. It was introduced in Go 1.11as an official solution for golang’s package management. With go modules mode, we no longer need to place our code in <strong>$GOPATH</strong> directory. </p><h1 id="Go-init"><a href="#Go-init" class="headerlink" title="Go init"></a>Go init</h1><p>In golang modules mode, we cant import our package in our project directly ( like what we do in python). Before we import our package, we need make it become a golang package first. And we should use <code>go mod init</code> command to make become a golang package in our project. </p><p>Usage:</p><pre><code>go mod init [module-path]</code></pre><p>Example:</p><pre><code># run it in "mypackage" foldergo mod init example.com/m</code></pre><p>If we have a package named “test”. Now we can import it from the path <strong>“example.com/m/mypackage/test”</strong>. </p><p>And after we run init command we can get a file named <code>go.mod</code> at the root of the project. It defines the module’s name, the Go version compatibility, and the required dependencies. The <code>go.mod</code> file is automatically created and updated as you add or remove dependencies.</p><h1 id="Solve-this-problem"><a href="#Solve-this-problem" class="headerlink" title="Solve this problem"></a>Solve this problem</h1><p>The answer is clear now. We shouldn’t use relative path to import our package if we want to use module mode. Just create new module and import it.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-package-management&quot;&gt;&lt;a href=&quot;#Golang-package-management&quot; class=&quot;headerlink&quot; title=&quot;Golang package management&quot;&gt;&lt;/a&gt;Golang pack</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>electron require is not defined</title>
    <link href="https://lele233.tech/2023/04/07/electron-require-is-not-defined/"/>
    <id>https://lele233.tech/2023/04/07/electron-require-is-not-defined/</id>
    <published>2023-04-07T03:50:43.000Z</published>
    <updated>2023-04-07T10:25:53.114Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是用于解决最新版本electron在浏览器侧文件如何引入nodejs下的包的问题。主要基于<a href="https://www.debugandrelease.com/the-ultimate-electron-guide/">The ultimate Electron guide</a>编写。</p><h1 id="Chromium-和-Node-如何交互？"><a href="#Chromium-和-Node-如何交互？" class="headerlink" title="Chromium 和 Node 如何交互？"></a>Chromium 和 Node 如何交互？</h1><p><strong>Electron</strong> 应用程序是一个<strong>npm项目</strong>，它包含electron框架作为依赖项。npm 项目的主要入口点是 Electron 应用程序的入口点，我们可以在其中选择性地包含我们想要的任何 <strong>Node API</strong>，以及创建并呈现UI的前端浏览器。<br><img src="https://s2.loli.net/2023/04/07/2lC5EGMu6znIA1V.png" alt="actual-arch-v2.png">  </p><h1 id="Chromium-and-Electron"><a href="#Chromium-and-Electron" class="headerlink" title="Chromium and Electron"></a>Chromium and Electron</h1><p>Chromium 从它的主进程开始。从主进程中，可以生成**渲染器进程(renderer)**。渲染器进程与[browser]窗口同义。主进程持有对渲染器进程的引用，并可以根据需要创建/删除渲染器进程。在大多数 Electron 应用程序中，只会创建一个渲染器进程，但如果需要更多渲染器进程，则没有硬性限制。<br>渲染进程与主进程的关系如图。<br><img src="https://s2.loli.net/2023/04/07/2QjwulY35UpT1Ve.png" alt="chromium-and-renderer-1-.png"><br>如若我们把渲染进程加入到之前的示意图中我们可以得到：<br><img src="https://s2.loli.net/2023/04/07/BitAfExRaeUZCbH.png" alt="chromium-in-npm-project.png"><br>我们可以通过创建一个window并使用loadurl等方法创建一个render进程。</p><h1 id="Node-API-in-Electron"><a href="#Node-API-in-Electron" class="headerlink" title="Node API in Electron"></a>Node API in Electron</h1><h2 id="第五版electron之前"><a href="#第五版electron之前" class="headerlink" title="第五版electron之前"></a>第五版electron之前</h2><p>在老版本的Electron中，我们可以直接倒入Node。只要我们创建window的时候启用<strong>nodeIntegrarion=true</strong>。</p><pre><code class="javascript">// in main.jsfunction createWindow () {  // Create the browser window.  mainWindow = new BrowserWindow({    width: 800,    height: 600,    webPreferences: {      preload: path.join(__dirname, 'preload.js'),      nodeIntegration:true //here    }</code></pre><p>此时我们的程序是可以随意require，访问node的。但是随之而来的就是很大的安全问题，如没有隔离等。<br><img src="https://s2.loli.net/2023/04/07/wRMW4hlptcVboXT.png" alt="node-in-renderer-process.png"></p><h2 id="Electron-5-and-IPC"><a href="#Electron-5-and-IPC" class="headerlink" title="Electron 5+ and IPC"></a>Electron 5+ and IPC</h2><p>如果我们无法在渲染器中引入node API 那我们该怎么办呢？ **IPC (inter-process communication)**is all you need! 事实上我们的主进程仅仅拥有renderer的引用，因此我们必须通过IPC进行通信。<br>IPC是基于事件进行通信的，实施IPC时，所有进程会监听事件，事件发生时则会进行执行。<br><img src="https://s2.loli.net/2023/04/07/uBwXtxWRGUZI89e.png" alt="chromium-ipc-listeners-1-.png">  </p><pre><code class="javascript">// code in mainconst {  app,  BrowserWindow,  ipcMain} = require("electron");const path = require("path");// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let win;async function createWindow() {  // Create the browser window.  win = new BrowserWindow({    width: 800,    height: 600  });  // Load app  win.loadFile(path.join(__dirname, "dist/index.html"));  // rest of code..}app.on("ready", createWindow);// Create an listener for the event "A"ipcMain.on("A", (event, args) =&gt; {      // Send result back to renderer process  win.webContents.send("D", {success: true});});</code></pre><pre><code class="javascript">// code in rendererconst {    ipcRenderer} = require("electron");window.sendToA = function(){    ipcRenderer.send("A");};window.receiveFromD = function(func){    ipcRenderer.on("D", (event, ...args) =&gt; func(event, ...args));};</code></pre><p>然而这只是示例，我们并不能在renderer.js 中直接<code>require("electron")</code> </p><h2 id="Preload-and-security"><a href="#Preload-and-security" class="headerlink" title="Preload and security"></a>Preload and security</h2><p>我特意忽略了在主进程和渲染进程之间通过 IPC 进行通信时所需的重要细节，这就是 Electron 团队定义为预加载脚本的内容。</p><p>由于我们的渲染器进程无法访问 Node，因此它们自己无法创建所需的 IPC 绑定！这个问题的答案是通过预加载脚本(<strong>preload.js</strong>)，它可以访问 Node API。我们在预加载脚本中创建渲染器 IPC 绑定；预加载脚本的内容被注入到我们的渲染器进程中.<br>我们可以在创建window的时候导入preload。</p><pre><code class="javascript">// Create the browser window.win = new BrowserWindow({  width: 800,  height: 600,  webPreferences: {    preload: path.join(__dirname, "preload.js")      }});</code></pre><p>但是事实上直接使用preload意味着我们全权信任渲染端，也就是服务器端，这很容易造成安全问题。<br>后面的一段代码将提供一个示例，说明这样使用preload有怎么样的问题。  </p><pre><code class="javascript">// preload.jsconst {    ipcRenderer} = require("electron");window.send = function(){    return ipcRenderer.send;};window.receive = function(){    return ipcRenderer.on;};</code></pre><pre><code class="html">&lt;!-- code in index.html --&gt;&lt;!doctype html&gt;&lt;html lang="en-US"&gt;&lt;head&gt;    &lt;meta charset="utf-8"/&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        // Called when message received from main process        window.receive()("fromMain", (data) =&gt; {            console.log(`Received ${data} from main process`);        });        // Send a message to the main process        window.send()("toMain", "some data");    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="javascript">// code in main.jsconst {  app,  BrowserWindow,  ipcMain} = require("electron");const path = require("path");const fs = require("fs");// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let win;async function createWindow() {  // Create the browser window.  win = new BrowserWindow({    width: 800,    height: 600,    webPreferences: {      preload: path.join(__dirname, "preload.js") // use a preload script    }  });  // Load app  win.loadFile(path.join(__dirname, "dist/index.html"));  // rest of code..}app.on("ready", createWindow);// Create a listener for deleting filesipcMain.on("deleteFile", (event, args) =&gt; {  fs.unlinkSync(args.filePath);      // Send the result back to the renderer process  win.webContents.send("deleteFileResponse", true);});</code></pre><p>如果我们错误地信任我们的渲染器进程，并且我们的代码前端被黑客攻击以将文件路径列表发送到“deleteFile”通道，我们可能会丢失计算机上的重要文件。这可能是一个人为的例子，但它表明如果我们不小心，有人可能会利用我们的代码来执行我们不希望的操作。<br>为了使用 IPC而不会受到函数覆盖的影响，我们需要使用上下文隔离(<strong>context isolation</strong>)。简而言之，上下文隔离创建了一个您在预加载中定义的不可变对象。渲染器进程无法更改任何具有上下文隔离的内容。幸运的是，设置上下文隔离非常容易。</p><h2 id="Preload-with-context-isolation"><a href="#Preload-with-context-isolation" class="headerlink" title="Preload with context isolation"></a>Preload with context isolation</h2><p>btw,从Electron版本 12开始，<strong>值contextIsolation默认为 true。</strong><br>我们在引入windows时使用的代码应该设置contextisolation值.</p><pre><code class="javascript">// Create the browser window.// code in main.jswin = new BrowserWindow({  width: 800,  height: 600,  webPreferences: {    contextIsolation: true,    preload: path.join(__dirname, "preload.js")      }});</code></pre><p>我们的预加载需要稍微改变以支持上下文隔离；我们需要使用electron中的<code>contextBridge</code>.</p><pre><code class="javascript">// code in preload.jsconst {    ipcRenderer,    contextBridge} = require("electron");// Expose protected methods off of window (ie.// window.api.sendToA) in order to use ipcRenderer// without exposing the entire objectcontextBridge.exposeInMainWorld("api", {    sendToA: function(){        ipcRenderer.send("A");    },    receiveFromD: function(func)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章是用于解决最新版本electron在浏览器侧文件如何引入nodejs下的包的问题。主要基于&lt;a href=&quot;https://www.debugandrelease.com/the-ultimate-electron-guide/&quot;&gt;The ultimate Elec</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>coredns插件原理与corefile原理</title>
    <link href="https://lele233.tech/2023/03/06/coredns%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E4%B8%8Ecorefile%E5%8E%9F%E7%90%86/"/>
    <id>https://lele233.tech/2023/03/06/coredns%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E4%B8%8Ecorefile%E5%8E%9F%E7%90%86/</id>
    <published>2023-03-06T12:43:23.000Z</published>
    <updated>2023-03-06T15:34:14.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是coredns？"><a href="#什么是coredns？" class="headerlink" title="什么是coredns？"></a>什么是coredns？</h1><p>coredns是谷歌开发并开源的一款dns解析服务器。其使用golang开发，提供了插件跨平台等特性。</p><h1 id="coredns插件"><a href="#coredns插件" class="headerlink" title="coredns插件"></a>coredns插件</h1><h2 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h2><p>coredns框架会在初始化时对插件进行注册，注册过后的插件可以被配置和调用。这里用 log 插件举例说明, 在 init() 内注册 log 的 setup 装载方法, 然后使用 AddPlugin 注册一个 plugin.Plugin 方法. 其目的就是要实现中间件那种调用链。其调用遵循一个调用链的倒叙。<br>代码位置: <code>plugin/log/setup.go</code>  </p><pre><code class="go">// 注册 log 插件, 把 log 的 setup 装载方法注册进去.func init() { plugin.Register("log", setup) }func setup(c *caddy.Controller) error {    // Logger 实现了 plugin.Handler 接口了, 注册一个 plugin.Plugin 方法.    dnsserver.GetConfig(c).AddPlugin(func(next plugin.Handler) plugin.Handler {        return Logger{Next: next, Rules: rules, repl: replacer.New()}    })    return nil}</code></pre><p>引入plugin时你需要在plugin.cfg 中引入。  </p><pre><code>external :dump:github.com/miekg/dumpofficial :sign:sign</code></pre><h2 id="调用插件"><a href="#调用插件" class="headerlink" title="调用插件"></a>调用插件</h2><p>coredns在注册server时会倒序遍历已经注册的plugin（这也意味着plugin的顺序是非常重要的）。<br>下图所示，当dns query到来之时，会按倒序调用plugin直到到达application。<br><img src="https://s2.loli.net/2023/03/06/uJXzYbTO49LcIA2.png" alt="plugin"></p><h1 id="corefile-的配置"><a href="#corefile-的配置" class="headerlink" title="corefile 的配置"></a>corefile 的配置</h1><p>Corefile是coerdns的配置文件，它定义了：  </p><ol><li>什么server监听什么端口和协议</li><li>每个服务器负责哪个<strong>zone</strong></li><li>每个server中会加载哪些plugin<br>其格式为：</li></ol><pre><code>ZONE:[PORT] {    [PLUGIN]...}</code></pre><p>这里的<strong>ZONE</strong> 定义此服务器的区域。 可选的 PORT 默认为 53，或 -dns.port 标志的值。<br><strong>PLUGIN</strong> 定义了我们要加载的插件。 这也是可选的，但是没有插件的服务器将只为所有查询返回 SERVFAIL。<br>当运行corefile的时候，你可以通过<code>conf</code>参数指定corefile，若未找到corefile，则会加载<code>whoami plugin</code>。</p><p>你无法为同一个zone的相同端口注册一样的server。比方说如下的两个注册会报错：</p><pre><code>. { }. { }</code></pre><p>error:  </p><pre><code>2017/07/23 20:39:10 cannot serve dns://.:53 - zone already defined for dns://.:53</code></pre><h1 id="coredns如何处理查询"><a href="#coredns如何处理查询" class="headerlink" title="coredns如何处理查询"></a>coredns如何处理查询</h1><p>不同的端口对应不同的server，换句话说，相同的<strong>端口</strong>，但是不同的<strong>zone</strong>处于同一个server。<br>如若我们写了如下的corefile：  </p><pre><code>coredns.io:5300 {  file /etc/coredns/zones/coredns.io.db}example.io:53 {  errors  log  file /etc/coredns/zones/example.io.db}example.net:53 {  file /etc/coredns/zones/example.net.db}.:53 {  errors  log  health  rewrite name foo.example.com foo.default.svc.cluster.local  kubernetes cluster.local 10.0.0.0/24  file /etc/coredns/example.db example.org  forward . /etc/resolv.conf  cache 30}</code></pre><p>如下图所示：<br><img src="https://s2.loli.net/2023/03/06/kFA3RXZLwqv7iSo.png" alt="query-processing"><br>由于我们在corefile中注册了两个端口，则生成了两个server。根据zone的不同，coredns会使用不同的插件链进行处理(插件链的顺序取决于注册顺序)。如果没有<code>zone</code> 匹配，<code>SERVFAIL</code> 则返回。<br>如果一个查询命中了<code>Corefile</code>中的某个区域<code>（Zone）</code>，那么默认情况下，CoreDNS将停止搜索其他插件，并直接返回匹配的结果。这是因为，如果一个查询命中了特定的区域，那么其他插件可能无法提供更准确的答案，因此继续搜索其他插件可能是浪费资源。</p><p>但是，你可以通过使用<code>fallthrough</code>指令来改变这种默认行为。<code>fallthrough</code>指令告诉CoreDNS在匹配了一个区域之后继续搜索其他插件。使用<code>fallthrough</code>指令可以在某些情况下提供更灵活的查询策略，但也可能会导致查询时间增加。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是coredns？&quot;&gt;&lt;a href=&quot;#什么是coredns？&quot; class=&quot;headerlink&quot; title=&quot;什么是coredns？&quot;&gt;&lt;/a&gt;什么是coredns？&lt;/h1&gt;&lt;p&gt;coredns是谷歌开发并开源的一款dns解析服务器。其使用gola</summary>
      
    
    
    
    
  </entry>
  
</feed>
