<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>electron require is not defined</title>
      <link href="/2023/04/07/electron-require-is-not-defined/"/>
      <url>/2023/04/07/electron-require-is-not-defined/</url>
      
        <content type="html"><![CDATA[<p>本篇文章是用于解决最新版本electron在浏览器侧文件如何引入nodejs下的包的问题。主要基于<a href="https://www.debugandrelease.com/the-ultimate-electron-guide/">The ultimate Electron guide</a>编写。</p><h1 id="Chromium-和-Node-如何交互？"><a href="#Chromium-和-Node-如何交互？" class="headerlink" title="Chromium 和 Node 如何交互？"></a>Chromium 和 Node 如何交互？</h1><p><strong>Electron</strong> 应用程序是一个<strong>npm项目</strong>，它包含electron框架作为依赖项。npm 项目的主要入口点是 Electron 应用程序的入口点，我们可以在其中选择性地包含我们想要的任何 <strong>Node API</strong>，以及创建并呈现UI的前端浏览器。<br><img src="https://s2.loli.net/2023/04/07/2lC5EGMu6znIA1V.png" alt="actual-arch-v2.png">  </p><h1 id="Chromium-and-Electron"><a href="#Chromium-and-Electron" class="headerlink" title="Chromium and Electron"></a>Chromium and Electron</h1><p>Chromium 从它的主进程开始。从主进程中，可以生成**渲染器进程(renderer)**。渲染器进程与[browser]窗口同义。主进程持有对渲染器进程的引用，并可以根据需要创建/删除渲染器进程。在大多数 Electron 应用程序中，只会创建一个渲染器进程，但如果需要更多渲染器进程，则没有硬性限制。<br>渲染进程与主进程的关系如图。<br><img src="https://s2.loli.net/2023/04/07/2QjwulY35UpT1Ve.png" alt="chromium-and-renderer-1-.png"><br>如若我们把渲染进程加入到之前的示意图中我们可以得到：<br><img src="https://s2.loli.net/2023/04/07/BitAfExRaeUZCbH.png" alt="chromium-in-npm-project.png"><br>我们可以通过创建一个window并使用loadurl等方法创建一个render进程。</p><h1 id="Node-API-in-Electron"><a href="#Node-API-in-Electron" class="headerlink" title="Node API in Electron"></a>Node API in Electron</h1><h2 id="第五版electron之前"><a href="#第五版electron之前" class="headerlink" title="第五版electron之前"></a>第五版electron之前</h2><p>在老版本的Electron中，我们可以直接倒入Node。只要我们创建window的时候启用<strong>nodeIntegrarion=true</strong>。</p><pre><code class="javascript">// in main.jsfunction createWindow () {  // Create the browser window.  mainWindow = new BrowserWindow({    width: 800,    height: 600,    webPreferences: {      preload: path.join(__dirname, 'preload.js'),      nodeIntegration:true //here    }</code></pre><p>此时我们的程序是可以随意require，访问node的。但是随之而来的就是很大的安全问题，如没有隔离等。<br><img src="https://s2.loli.net/2023/04/07/wRMW4hlptcVboXT.png" alt="node-in-renderer-process.png"></p><h2 id="Electron-5-and-IPC"><a href="#Electron-5-and-IPC" class="headerlink" title="Electron 5+ and IPC"></a>Electron 5+ and IPC</h2><p>如果我们无法在渲染器中引入node API 那我们该怎么办呢？ **IPC (inter-process communication)**is all you need! 事实上我们的主进程仅仅拥有renderer的引用，因此我们必须通过IPC进行通信。<br>IPC是基于事件进行通信的，实施IPC时，所有进程会监听事件，事件发生时则会进行执行。<br><img src="https://s2.loli.net/2023/04/07/uBwXtxWRGUZI89e.png" alt="chromium-ipc-listeners-1-.png">  </p><pre><code class="javascript">// code in mainconst {  app,  BrowserWindow,  ipcMain} = require("electron");const path = require("path");// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let win;async function createWindow() {  // Create the browser window.  win = new BrowserWindow({    width: 800,    height: 600  });  // Load app  win.loadFile(path.join(__dirname, "dist/index.html"));  // rest of code..}app.on("ready", createWindow);// Create an listener for the event "A"ipcMain.on("A", (event, args) =&gt; {      // Send result back to renderer process  win.webContents.send("D", {success: true});});</code></pre><pre><code class="javascript">// code in rendererconst {    ipcRenderer} = require("electron");window.sendToA = function(){    ipcRenderer.send("A");};window.receiveFromD = function(func){    ipcRenderer.on("D", (event, ...args) =&gt; func(event, ...args));};</code></pre><p>然而这只是示例，我们并不能在renderer.js 中直接<code>require("electron")</code> </p><h2 id="Preload-and-security"><a href="#Preload-and-security" class="headerlink" title="Preload and security"></a>Preload and security</h2><p>我特意忽略了在主进程和渲染进程之间通过 IPC 进行通信时所需的重要细节，这就是 Electron 团队定义为预加载脚本的内容。</p><p>由于我们的渲染器进程无法访问 Node，因此它们自己无法创建所需的 IPC 绑定！这个问题的答案是通过预加载脚本(<strong>preload.js</strong>)，它可以访问 Node API。我们在预加载脚本中创建渲染器 IPC 绑定；预加载脚本的内容被注入到我们的渲染器进程中.<br>我们可以在创建window的时候导入preload。</p><pre><code class="javascript">// Create the browser window.win = new BrowserWindow({  width: 800,  height: 600,  webPreferences: {    preload: path.join(__dirname, "preload.js")      }});</code></pre><p>但是事实上直接使用preload意味着我们全权信任渲染端，也就是服务器端，这很容易造成安全问题。<br>后面的一段代码将提供一个示例，说明这样使用preload有怎么样的问题。  </p><pre><code class="javascript">// preload.jsconst {    ipcRenderer} = require("electron");window.send = function(){    return ipcRenderer.send;};window.receive = function(){    return ipcRenderer.on;};</code></pre><pre><code class="html">&lt;!-- code in index.html --&gt;&lt;!doctype html&gt;&lt;html lang="en-US"&gt;&lt;head&gt;    &lt;meta charset="utf-8"/&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        // Called when message received from main process        window.receive()("fromMain", (data) =&gt; {            console.log(`Received ${data} from main process`);        });        // Send a message to the main process        window.send()("toMain", "some data");    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="javascript">// code in main.jsconst {  app,  BrowserWindow,  ipcMain} = require("electron");const path = require("path");const fs = require("fs");// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let win;async function createWindow() {  // Create the browser window.  win = new BrowserWindow({    width: 800,    height: 600,    webPreferences: {      preload: path.join(__dirname, "preload.js") // use a preload script    }  });  // Load app  win.loadFile(path.join(__dirname, "dist/index.html"));  // rest of code..}app.on("ready", createWindow);// Create a listener for deleting filesipcMain.on("deleteFile", (event, args) =&gt; {  fs.unlinkSync(args.filePath);      // Send the result back to the renderer process  win.webContents.send("deleteFileResponse", true);});</code></pre><p>如果我们错误地信任我们的渲染器进程，并且我们的代码前端被黑客攻击以将文件路径列表发送到“deleteFile”通道，我们可能会丢失计算机上的重要文件。这可能是一个人为的例子，但它表明如果我们不小心，有人可能会利用我们的代码来执行我们不希望的操作。<br>为了使用 IPC而不会受到函数覆盖的影响，我们需要使用上下文隔离(<strong>context isolation</strong>)。简而言之，上下文隔离创建了一个您在预加载中定义的不可变对象。渲染器进程无法更改任何具有上下文隔离的内容。幸运的是，设置上下文隔离非常容易。</p><h2 id="Preload-with-context-isolation"><a href="#Preload-with-context-isolation" class="headerlink" title="Preload with context isolation"></a>Preload with context isolation</h2><p>btw,从Electron版本 12开始，<strong>值contextIsolation默认为 true。</strong><br>我们在引入windows时使用的代码应该设置contextisolation值.</p><pre><code class="javascript">// Create the browser window.// code in main.jswin = new BrowserWindow({  width: 800,  height: 600,  webPreferences: {    contextIsolation: true,    preload: path.join(__dirname, "preload.js")      }});</code></pre><p>我们的预加载需要稍微改变以支持上下文隔离；我们需要使用electron中的<code>contextBridge</code>.</p><pre><code class="javascript">// code in preload.jsconst {    ipcRenderer,    contextBridge} = require("electron");// Expose protected methods off of window (ie.// window.api.sendToA) in order to use ipcRenderer// without exposing the entire objectcontextBridge.exposeInMainWorld("api", {    sendToA: function(){        ipcRenderer.send("A");    },    receiveFromD: function(func)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>coredns插件原理与corefile原理</title>
      <link href="/2023/03/06/coredns%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E4%B8%8Ecorefile%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/06/coredns%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E4%B8%8Ecorefile%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是coredns？"><a href="#什么是coredns？" class="headerlink" title="什么是coredns？"></a>什么是coredns？</h1><p>coredns是谷歌开发并开源的一款dns解析服务器。其使用golang开发，提供了插件跨平台等特性。</p><h1 id="coredns插件"><a href="#coredns插件" class="headerlink" title="coredns插件"></a>coredns插件</h1><h2 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h2><p>coredns框架会在初始化时对插件进行注册，注册过后的插件可以被配置和调用。这里用 log 插件举例说明, 在 init() 内注册 log 的 setup 装载方法, 然后使用 AddPlugin 注册一个 plugin.Plugin 方法. 其目的就是要实现中间件那种调用链。其调用遵循一个调用链的倒叙。<br>代码位置: <code>plugin/log/setup.go</code>  </p><pre><code class="go">// 注册 log 插件, 把 log 的 setup 装载方法注册进去.func init() { plugin.Register("log", setup) }func setup(c *caddy.Controller) error {    // Logger 实现了 plugin.Handler 接口了, 注册一个 plugin.Plugin 方法.    dnsserver.GetConfig(c).AddPlugin(func(next plugin.Handler) plugin.Handler {        return Logger{Next: next, Rules: rules, repl: replacer.New()}    })    return nil}</code></pre><p>引入plugin时你需要在plugin.cfg 中引入。  </p><pre><code>external :dump:github.com/miekg/dumpofficial :sign:sign</code></pre><h2 id="调用插件"><a href="#调用插件" class="headerlink" title="调用插件"></a>调用插件</h2><p>coredns在注册server时会倒序遍历已经注册的plugin（这也意味着plugin的顺序是非常重要的）。<br>下图所示，当dns query到来之时，会按倒序调用plugin直到到达application。<br><img src="https://s2.loli.net/2023/03/06/uJXzYbTO49LcIA2.png" alt="plugin"></p><h1 id="corefile-的配置"><a href="#corefile-的配置" class="headerlink" title="corefile 的配置"></a>corefile 的配置</h1><p>Corefile是coerdns的配置文件，它定义了：  </p><ol><li>什么server监听什么端口和协议</li><li>每个服务器负责哪个<strong>zone</strong></li><li>每个server中会加载哪些plugin<br>其格式为：</li></ol><pre><code>ZONE:[PORT] {    [PLUGIN]...}</code></pre><p>这里的<strong>ZONE</strong> 定义此服务器的区域。 可选的 PORT 默认为 53，或 -dns.port 标志的值。<br><strong>PLUGIN</strong> 定义了我们要加载的插件。 这也是可选的，但是没有插件的服务器将只为所有查询返回 SERVFAIL。<br>当运行corefile的时候，你可以通过<code>conf</code>参数指定corefile，若未找到corefile，则会加载<code>whoami plugin</code>。</p><p>你无法为同一个zone的相同端口注册一样的server。比方说如下的两个注册会报错：</p><pre><code>. { }. { }</code></pre><p>error:  </p><pre><code>2017/07/23 20:39:10 cannot serve dns://.:53 - zone already defined for dns://.:53</code></pre><h1 id="coredns如何处理查询"><a href="#coredns如何处理查询" class="headerlink" title="coredns如何处理查询"></a>coredns如何处理查询</h1><p>不同的端口对应不同的server，换句话说，相同的<strong>端口</strong>，但是不同的<strong>zone</strong>处于同一个server。<br>如若我们写了如下的corefile：  </p><pre><code>coredns.io:5300 {  file /etc/coredns/zones/coredns.io.db}example.io:53 {  errors  log  file /etc/coredns/zones/example.io.db}example.net:53 {  file /etc/coredns/zones/example.net.db}.:53 {  errors  log  health  rewrite name foo.example.com foo.default.svc.cluster.local  kubernetes cluster.local 10.0.0.0/24  file /etc/coredns/example.db example.org  forward . /etc/resolv.conf  cache 30}</code></pre><p>如下图所示：<br><img src="https://s2.loli.net/2023/03/06/kFA3RXZLwqv7iSo.png" alt="query-processing"><br>由于我们在corefile中注册了两个端口，则生成了两个server。根据zone的不同，coredns会使用不同的插件链进行处理(插件链的顺序取决于注册顺序)。如果没有<code>zone</code> 匹配，<code>SERVFAIL</code> 则返回。<br>如果一个查询命中了<code>Corefile</code>中的某个区域<code>（Zone）</code>，那么默认情况下，CoreDNS将停止搜索其他插件，并直接返回匹配的结果。这是因为，如果一个查询命中了特定的区域，那么其他插件可能无法提供更准确的答案，因此继续搜索其他插件可能是浪费资源。</p><p>但是，你可以通过使用<code>fallthrough</code>指令来改变这种默认行为。<code>fallthrough</code>指令告诉CoreDNS在匹配了一个区域之后继续搜索其他插件。使用<code>fallthrough</code>指令可以在某些情况下提供更灵活的查询策略，但也可能会导致查询时间增加。  </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
